move to unscoped instead of escapes
write doc in terms of the break
tone down the compat issue
clean up references to new-span (is that anchor still needed?)
clean up references to new-span-challenges (is that anchor still needed?)
clean up references to ref-field-reassignment (is that anchor still needed?)
compat consideration section include
  - discussion on allowing ref to have granularity of ref return
consideration for relative lifetimes 
where do we say that escaping by ref as a field or direct will be the same thing
in unscoped mention it can mitigate the `out` change if desired
move the `scoped local` example to the examples section
delete **old stuff**
update method args must match rule in the main section



**OLD STUFF**

The creation of `ref` fields mean the rules need to account for two types of `ref` escape: 

1. Directly as a `ref` return
2. As a `ref` field inside a `ref struct` returned by value

The design could allow for `ref` parameters to have this level of granularity. Being annotated as 

Allowing a `ref` parameter to specify it 

Supporting this level of granularity 
This level of granularity though significantly complicates 



However this section of the proposal is quite involved. The reason is to make sure the reader understands both the new rules and **why** they were chosen. There are a number of subtle interactions between `ref` fields and our [compat considerations](#compat-considerations) that are easy to miss. This section is meant to call these out and explain how they fit into the chosen rules.

The [new Span<T> definition](#new-span) also reveals several [challenges](#new-span-challenges) that must be resolved for the lifetime of types that contain `ref` fields. They must both take into account the lifetime of captured values as well as the compat considerations.

The rules we define for `ref` fields must ensure the `Span<T>` constructor properly restricts the *safe-to-escape* scope of constructed objects in the cases it captures `ref` state. At the same time it must ensure that we don't break the existing consumption rules for methods like `CreateSpan<T>`. 

<a name="ref-field-escapes"></a>

To accomplish this two new annotations will be introduced to help control how arguments influence lifetime of method calls: `[RefFieldEscapes]` and `[DoesNotEscape]`. The annotation `[RefFieldEscapes]` when applied to a `ref` parameter signifies that it can be captured as a `ref` field in a returned `ref struct`.

The `[DoesNotEscape]` annotation is not necessary for `ref` fields but more for reducing friction when dealing with specific classes of methods. It will be discussed in detail [later on](#does-not-escape) but needs to be introduced now as it impacts method invocation rules.

To recognize these annotations the span safety rules for method invocation need to be updated. The first change is recognizing the impact the annotations have on arguments. For a given argument `a` that is passed to `ref` parameter `p`: 

> 1. If `p` is `[RefFieldEscapes] ref` or `[RefFieldEscapes] in` and `a` is 
>     1. A `[RefFieldEscapes]` parameter it contributes *safe-to-escape* to *calling method*
>     2. A known heap location it contributes *safe-to-escape* to *calling method*
>     3. It contributes *safe-to-escape* to *current method*
> 2. If `p` is `[DoesNotEscape]` then `a` does not contribute *safe-to-escape* when considering arguments.

This change allows us to keep our existing rules for rvalue method invocation:

> An rvalue resulting from a method invocation e1.M(e2, ...) is *safe-to-escape* from the smallest of the following scopes:
> * The entire enclosing method
> * The *safe-to-escape* of all argument expressions (including the receiver)

The rules for `ref` field assignment will be discussed in detail [later on](#rules-ref-field-reassignment) the doc. For now readers only need to know constructors can initialize `ref` fields with parameters marked as `[RefFieldEscapes]` or known heap locations.

Let's examine these rules in the context of samples to better understand their impact and how they maintain the required compat considerations.

```c#
ref struct RS
{
    ref int _field;

    public RS(int[] array, int index)
    {
        // Okay: as fields are initialized with known heap values. Caller does not need a visible
        // change as it does not provide values that participate in this capture.
        _field = ref array[index];
    }

    public RS([RefFieldEscapes] ref int value)
    {
        // Okay: the parameter `value` is annotated with [RefFieldEscapes] which allows for 
        // it to be assigned to a ref field. This also makes the capture visible to the 
        // caller
        _field = ref value;
    }

    public RS(ref (int, int) tuple)
    {
        // Error: even though the ref-safe-to-escape of `tuple.Item1` is to the calling method, the 
        // parameter is not annotated with [RefFieldEscapes] hence it cannot be ref reassigned to a 
        // ref field
        _field = ref tuple.Item1;
    }

    static RS CreateRS([RefFieldEscapes] ref int p1, ref int p2)
    {
        // Okay: The RS argument `p1' lines up with a [RefFieldEscapes] argument
        // but it is also a [RefFieldEscapes] parameter hence it contributes a safe-to-escape of 
        // calling method (rule 1.1 above)
        return new RS(ref p1);

        // Okay: This is a known heap value hence it is safe-to-escape to the calling
        // method (rule 1.2 above)
        return new RS(new int[1]);

        // Error: This is the same analysis as above but in this case `p2` is not 
        // [RefFieldEscapes] hence it contributes safe-to-escape of current method
        // (rule 1.3 above)
        return new RS(ref p2);

        // Error: This is the same analysis as above and once again by rule 1.3 is 
        // only safe-to-escape to the current method
        int local = 42;
        return new RS(ref local);
    }
}
```

The samples here have the same patterns as the [compat considerations](#compat-considerations) above. This means it will allow the introduction of `ref` fields without breaking existing code.

This proposal also requires that the span safety rules for field lifetimes be expanded as the rules today simply don't explicitly account for `ref` fields. It's important to note that our expansion of the rules here is not defining new behavior but rather accounting for behavior that has long existed. The safety rules around using `ref struct` fully acknowledge and account for the possibility that `ref struct` will contain `ref` fields and that `ref` fields will be exposed to consumers. The most prominent example of this is the indexer on `Span<T>`:

``` cs
readonly ref struct Span<T>
{
    public ref T this[int index] => ...; 
}
```

This directly exposes the `ref` state inside `Span<T>` and the span safety rules account for this. Whether that was implemented as `ByReference<T>` or `ref` fields is immaterial to those rules. This is true even though normal fields cannot be returned by `ref`. Effectively the rules have **always** allowed for the following: 

```c#
ref struct S
{
    int _field1;
    ref int _field2;

    internal ref int Prop1 => ref _field1;  // Error: can't escape `this` by ref
    internal ref int Prop2 => ref _field2;  // Okay 
}
```

As a part of allowing `ref` fields though we must define their rules such that they fit into the existing consumption rules for `ref struct`. Specifically this must account for the fact that it's legal *today* for a `ref struct` to return its `ref` state as `ref` to the consumer. 

To understand the proposed changes it's helpful to first review the existing rules for method invocation around *ref-safe-to-escape* and how they account for a `ref struct` exposing `ref` state today:

> An lvalue resulting from a ref-returning method invocation e1.M(e2, ...) is *ref-safe-to-escape* the smallest of the following scopes:
> 1. The entire enclosing method
> 2. The *ref-safe-to-escape* of all ref and out argument expressions (excluding the receiver)
> 3. For each in parameter of the method, if there is a corresponding expression that is an lvalue, its *ref-safe-to-escape*, otherwise the nearest enclosing scope
> 4. the *safe-to-escape* of all argument expressions (including the receiver)

The fourth item provides the critical safety point around a `ref struct` exposing `ref` state to callers. When the `ref` state stored in a `ref struct` refers to the stack then the *safe-to-escape* scope for that `ref struct` will be at most the scope which defines the state being referred to. Hence limiting the *ref-safe-to-escape* of invocations of a `ref struct` to the *safe-to-escape* scope of the receiver ensures the lifetimes are correct.

Consider as an example the indexer on `Span<T>` which is returning `ref` fields by `ref` today. The fourth item here is what provides the safety here:

```c#
ref int Examples()
{
    Span<int> s1 = stackalloc int[5];

    // Error: illegal because the *safe-to-escape* scope of `s1` is the current
    // method scope hence that limits the *ref-safe-to-escape" to the current
    // method scope as well.
    return ref s1[0];

    // Okay: legal because the *safe-to-escape* scope of `s2` is outside
    // the current method scope hence the *ref-safe-to-escape* is as well
    Span<int> s2 = default;
    return ref s2[0];
}
```

To account for `ref` fields the *ref-safe-to-escape* rules for fields will be adjusted to the following:

> An lvalue designating a reference to a field, e.F, is *ref-safe-to-escape* (by reference) as follows:
> 1. If `F` is a `ref` field and `e` is `this`, it is *ref-safe-to-escape* from the enclosing method.
> 2. Else if `F` is a `ref` field its *ref-safe-to-escape* scope is the *safe-to-escape* scope of `e`.
> 3. Else if `e` is of a reference type, it is *ref-safe-to-escape* from the enclosing method.
> 4. Else its *ref-safe-to-escape* is taken from the *ref-safe-to-escape* of `e`.

This explicitly allows for `ref` fields being returned as `ref` from a `ref struct` but not normal fields (that will be covered later). 

```c#
ref struct RS
{
    ref int _refField;
    int _field;

    // Okay: this falls into bullet one above. 
    public ref int Prop1 => ref _refField;

    // Error: This is bullet four above and the *ref-safe-to-escape* of `this`
    // in a `struct` is the current method scope.
    public ref int Prop2 => ref _field;

    public RS(int[] array)
    {
        _refField = ref array[0];
    }

    public RS(ref int i)
    {
        _refField = ref i;
    }

    public RS CreateRS() => ...;

    public ref int M1(RS rs)
    {
        ref int local1 = ref rs.Prop1;

        // Okay: this falls into bullet two above and the *safe-to-escape* of
        // `rs` is outside the current method scope. Hence the *ref-safe-to-escape*
        // of `local1` is outside the current method scope.
        return ref local;

        // Okay: this falls into bullet two above and the *safe-to-escape* of
        // `rs` is outside the current method scope. Hence the *ref-safe-to-escape*
        // of `local1` is outside the current method scope.
        //
        // In fact in this scenario you can guarantee that the value returned
        // from Prop1 must exist on the heap. 
        RS local2 = CreateRS();
        return ref local2.Prop1;

        // Error: the *safe-to-escape* of `local4` here is the current method 
        // scope by the revised constructor rules. This falls into bullet two 
        // above and hence based on that allowed scope.
        int local3 = 42;
        var local4 = new RS(ref local3);
        return ref local4.Prop1;

    }
}
```

<a name="ref-field-reassignment"></a>

The rules for `ref` reassignment will be adjusted to account for `ref` fields as follows:

> For a ref reassignment in the form ...
> 1. `x.e1 = ref e2`: the `e2` must be a `[RefFieldEscapes]` parameter or refer to a known heap location else it is an error
> 2. `e1 = ref e2`: the *ref-safe-to-escape* of `e2` must be at least as wide a scope as the *ref-safe-to-escape* of `e1`.

Examples of these rules in practice:

```c#
ref struct SmallSpan
{
    public ref int _field;

    // Notice once again we're back at the same problem as the original 
    // CreateSpan method: a method returning a ref struct and taking a ref
    // parameter
    SmallSpan TrickyRefAssignment(ref int i)
    {
        // *safe-to-escape* is outside the current method by current rules.
        SmallSpan s = default;

        // The *ref-safe-to-escape* of 'i' is the same as the *safe-to-escape*
        // of 's' hence most assignment rules would allow it.
        s._field = ref i;

        // Error: this must be disallowed for the exact same reasons we can't 
        // return a Span<T> wrapping the parameter: the consumption rules
        // believe such state smuggling cannot exist
        return s;
    }

    SmallSpan SafeRefAssignment()
    {
        int[] array = new int[] { 42, 13 };
        SmallSpan s = default;

        // Okay: the value being assigned here is known to refer to the heap 
        // hence it is allowed by our rules above because it requires no changes
        // to existing method invocation rules (hence preserves compat)
        s._field = ref array[i];

        return s;
    }

    SmallSpan BadUsage()
    {
        // Legal today and must remain legal (and safe)
        int i = 0;
        return TrickyRefAssignment(ref i);
    }
}
```

There are designs choices we could make to allow more flexible `ref` re-assignment of fields. For example it could be allowed in cases where we knew the receiver had a *safe-to-escape* scope that was not outside the current method scope. Further we could provide syntax for making such downward facing values easier to declare: essentially values that have *safe-to-escape* scopes restricted to the current method. Such a design is discussed [here](https://github.com/dotnet/csharplang/discussions/1130)). However extra complexity of such rules do not seem to be worth the limited cases this enables. Should compelling samples come up we can revisit this decision.

This means though that `ref` fields are largely in practice `readonly ref`. The main exceptions being object initializers and when the value is known to refer to the heap.
